{"ast":null,"code":"import { ref, watchEffect } from 'vue';\nimport { projectFirestore } from '../firebase/config';\n\nconst getCollection = (collection, query) => {\n  const documents = ref(null);\n  const error = ref(null); // register the firestore collection reference\n\n  let collectionRef = projectFirestore.collection(collection).orderBy('createdAt');\n\n  if (query) {\n    collectionRef = collectionRef.where(...query);\n  }\n\n  const unsub = collectionRef.onSnapshot(snap => {\n    let results = [];\n    snap.docs.forEach(doc => {\n      // must wait for the server to create the timestamp & send it back\n      doc.data().createdAt && results.push({ ...doc.data(),\n        id: doc.id\n      });\n    }); // update values\n\n    documents.value = results;\n    error.value = null;\n  }, err => {\n    console.log(err.message);\n    documents.value = null;\n    error.value = 'could not fetch the data';\n  });\n  watchEffect(onInvalidate => {\n    onInvalidate(() => unsub());\n  });\n  return {\n    error,\n    documents\n  };\n};\n\nexport default getCollection;","map":{"version":3,"sources":["/home/saumya/Documents/Project.Tech/project-tech/src/composables/getCollection.js"],"names":["ref","watchEffect","projectFirestore","getCollection","collection","query","documents","error","collectionRef","orderBy","where","unsub","onSnapshot","snap","results","docs","forEach","doc","data","createdAt","push","id","value","err","console","log","message","onInvalidate"],"mappings":"AAAA,SAASA,GAAT,EAAcC,WAAd,QAAiC,KAAjC;AACA,SAASC,gBAAT,QAAiC,oBAAjC;;AAEA,MAAMC,aAAa,GAAG,CAACC,UAAD,EAAaC,KAAb,KAAuB;AAE3C,QAAMC,SAAS,GAAGN,GAAG,CAAC,IAAD,CAArB;AACA,QAAMO,KAAK,GAAGP,GAAG,CAAC,IAAD,CAAjB,CAH2C,CAK3C;;AACA,MAAIQ,aAAa,GAAGN,gBAAgB,CAACE,UAAjB,CAA4BA,UAA5B,EACjBK,OADiB,CACT,WADS,CAApB;;AAGA,MAAIJ,KAAJ,EAAW;AACTG,IAAAA,aAAa,GAAGA,aAAa,CAACE,KAAd,CAAoB,GAAGL,KAAvB,CAAhB;AACD;;AAED,QAAMM,KAAK,GAAGH,aAAa,CAACI,UAAd,CAAyBC,IAAI,IAAI;AAC7C,QAAIC,OAAO,GAAG,EAAd;AACAD,IAAAA,IAAI,CAACE,IAAL,CAAUC,OAAV,CAAkBC,GAAG,IAAI;AACvB;AACAA,MAAAA,GAAG,CAACC,IAAJ,GAAWC,SAAX,IAAwBL,OAAO,CAACM,IAAR,CAAa,EAAC,GAAGH,GAAG,CAACC,IAAJ,EAAJ;AAAgBG,QAAAA,EAAE,EAAEJ,GAAG,CAACI;AAAxB,OAAb,CAAxB;AACD,KAHD,EAF6C,CAO7C;;AACAf,IAAAA,SAAS,CAACgB,KAAV,GAAkBR,OAAlB;AACAP,IAAAA,KAAK,CAACe,KAAN,GAAc,IAAd;AACD,GAVa,EAUXC,GAAG,IAAI;AACRC,IAAAA,OAAO,CAACC,GAAR,CAAYF,GAAG,CAACG,OAAhB;AACApB,IAAAA,SAAS,CAACgB,KAAV,GAAkB,IAAlB;AACAf,IAAAA,KAAK,CAACe,KAAN,GAAc,0BAAd;AACD,GAda,CAAd;AAgBArB,EAAAA,WAAW,CAAE0B,YAAD,IAAkB;AAC5BA,IAAAA,YAAY,CAAC,MAAMhB,KAAK,EAAZ,CAAZ;AACD,GAFU,CAAX;AAIA,SAAO;AAAEJ,IAAAA,KAAF;AAASD,IAAAA;AAAT,GAAP;AACD,CAlCD;;AAoCA,eAAeH,aAAf","sourcesContent":["import { ref, watchEffect } from 'vue'\nimport { projectFirestore } from '../firebase/config'\n\nconst getCollection = (collection, query) => {\n\n  const documents = ref(null)\n  const error = ref(null)\n\n  // register the firestore collection reference\n  let collectionRef = projectFirestore.collection(collection)\n    .orderBy('createdAt')\n\n  if (query) {\n    collectionRef = collectionRef.where(...query)\n  }\n\n  const unsub = collectionRef.onSnapshot(snap => {\n    let results = []\n    snap.docs.forEach(doc => {\n      // must wait for the server to create the timestamp & send it back\n      doc.data().createdAt && results.push({...doc.data(), id: doc.id})\n    });\n    \n    // update values\n    documents.value = results\n    error.value = null\n  }, err => {\n    console.log(err.message)\n    documents.value = null\n    error.value = 'could not fetch the data'\n  })\n\n  watchEffect((onInvalidate) => {\n    onInvalidate(() => unsub());\n  });\n\n  return { error, documents }\n}\n\nexport default getCollection"]},"metadata":{},"sourceType":"module"}